/*
Copyright 2022.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
//go:build !ignore_autogenerated
// +build !ignore_autogenerated

// Code generated by kcp code-generator. DO NOT EDIT.

package v1alpha1

import (
	kcpcache "github.com/kcp-dev/apimachinery/v2/pkg/cache"	
	"github.com/kcp-dev/logicalcluster/v3"
	
	"k8s.io/client-go/tools/cache"
	"k8s.io/apimachinery/pkg/labels"
	"k8s.io/apimachinery/pkg/api/errors"

	pluginsv1alpha1 "github.com/faroshq/faros-hub/pkg/apis/plugins/v1alpha1"
	)

// PluginClusterLister can list Plugins across all workspaces, or scope down to a PluginLister for one workspace.
// All objects returned here must be treated as read-only.
type PluginClusterLister interface {
	// List lists all Plugins in the indexer.
	// Objects returned here must be treated as read-only.
	List(selector labels.Selector) (ret []*pluginsv1alpha1.Plugin, err error)
	// Cluster returns a lister that can list and get Plugins in one workspace.
Cluster(clusterName logicalcluster.Name) PluginLister
PluginClusterListerExpansion
}

type pluginClusterLister struct {
	indexer cache.Indexer
}

// NewPluginClusterLister returns a new PluginClusterLister.
// We assume that the indexer:
// - is fed by a cross-workspace LIST+WATCH
// - uses kcpcache.MetaClusterNamespaceKeyFunc as the key function
// - has the kcpcache.ClusterIndex as an index
func NewPluginClusterLister(indexer cache.Indexer) *pluginClusterLister {
	return &pluginClusterLister{indexer: indexer}
}

// List lists all Plugins in the indexer across all workspaces.
func (s *pluginClusterLister) List(selector labels.Selector) (ret []*pluginsv1alpha1.Plugin, err error) {
	err = cache.ListAll(s.indexer, selector, func(m interface{}) {
		ret = append(ret, m.(*pluginsv1alpha1.Plugin))
	})
	return ret, err
}

// Cluster scopes the lister to one workspace, allowing users to list and get Plugins.
func (s *pluginClusterLister) Cluster(clusterName logicalcluster.Name) PluginLister {
return &pluginLister{indexer: s.indexer, clusterName: clusterName}
}

// PluginLister can list all Plugins, or get one in particular.
// All objects returned here must be treated as read-only.
type PluginLister interface {
	// List lists all Plugins in the workspace.
	// Objects returned here must be treated as read-only.
	List(selector labels.Selector) (ret []*pluginsv1alpha1.Plugin, err error)
// Get retrieves the Plugin from the indexer for a given workspace and name.
	// Objects returned here must be treated as read-only.
	Get(name string) (*pluginsv1alpha1.Plugin, error)
PluginListerExpansion
}
// pluginLister can list all Plugins inside a workspace.
type pluginLister struct {
	indexer cache.Indexer
	clusterName logicalcluster.Name
}

// List lists all Plugins in the indexer for a workspace.
func (s *pluginLister) List(selector labels.Selector) (ret []*pluginsv1alpha1.Plugin, err error) {
	err = kcpcache.ListAllByCluster(s.indexer, s.clusterName, selector, func(i interface{}) {
		ret = append(ret, i.(*pluginsv1alpha1.Plugin))
	})
	return ret, err
}

// Get retrieves the Plugin from the indexer for a given workspace and name.
func (s *pluginLister) Get(name string) (*pluginsv1alpha1.Plugin, error) {
	key := kcpcache.ToClusterAwareKey(s.clusterName.String(), "", name)
	obj, exists, err := s.indexer.GetByKey(key)
	if err != nil {
		return nil, err
	}
	if !exists {
		return nil, errors.NewNotFound(pluginsv1alpha1.Resource("Plugin"), name)
	}
	return obj.(*pluginsv1alpha1.Plugin), nil
}
// NewPluginLister returns a new PluginLister.
// We assume that the indexer:
// - is fed by a workspace-scoped LIST+WATCH
// - uses cache.MetaNamespaceKeyFunc as the key function
func NewPluginLister(indexer cache.Indexer) *pluginScopedLister {
	return &pluginScopedLister{indexer: indexer}
}

// pluginScopedLister can list all Plugins inside a workspace.
type pluginScopedLister struct {
	indexer cache.Indexer
}

// List lists all Plugins in the indexer for a workspace.
func (s *pluginScopedLister) List(selector labels.Selector) (ret []*pluginsv1alpha1.Plugin, err error) {
	err = cache.ListAll(s.indexer, selector, func(i interface{}) {
		ret = append(ret, i.(*pluginsv1alpha1.Plugin))
	})
	return ret, err
}

// Get retrieves the Plugin from the indexer for a given workspace and name.
func (s *pluginScopedLister) Get(name string) (*pluginsv1alpha1.Plugin, error) {
	key := name
	obj, exists, err := s.indexer.GetByKey(key)
	if err != nil {
		return nil, err
	}
	if !exists {
		return nil, errors.NewNotFound(pluginsv1alpha1.Resource("Plugin"), name)
	}
	return obj.(*pluginsv1alpha1.Plugin), nil
}
